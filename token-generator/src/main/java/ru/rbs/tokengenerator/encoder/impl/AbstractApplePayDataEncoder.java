package ru.rbs.tokengenerator.encoder.impl;


import org.apache.commons.lang.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.bpc.phoenix.model.ApplePay;
import ru.bpc.service.CertificateService;
import ru.rbs.commons.encrypt.CryptoService;
import ru.rbs.tokengenerator.applepay.ApplePayCertificateAlgorithm;
import ru.rbs.tokengenerator.applepay.ApplePayDummyConstant;
import ru.rbs.tokengenerator.applepay.ApplePayPaymentData;
import ru.rbs.tokengenerator.applepay.ApplePayPaymentToken;
import ru.rbs.tokengenerator.dao.ApplePayDao;
import ru.rbs.tokengenerator.encoder.ApplePayDataEncoder;
import ru.rbs.tokengenerator.exception.ApplePayNotFoundException;

import javax.annotation.Resource;
import java.security.PrivateKey;
import java.util.Base64;
import java.util.List;

public abstract class AbstractApplePayDataEncoder implements ApplePayDataEncoder {

    private final static Logger logger = LoggerFactory.getLogger(AbstractApplePayDataEncoder.class);

    @Resource
    private CryptoService aesCryptUtil;
    @Resource
    private ApplePayDao applePayDao;

    @Override
    public ApplePayPaymentToken encode(@NotNull List<ApplePay> applePays, @NotNull ApplePayPaymentData applePayPaymentData) throws ApplePayNotFoundException {
        ApplePayPaymentToken applePayPaymentToken = new ApplePayPaymentToken();
        ApplePayPaymentToken.Header header = new ApplePayPaymentToken.Header();
        for (ApplePay applePay : applePays) {
            try {
                if (!isValidate(applePay)) {
                    continue;
                }
                String privateKey = applePay.getPrivateKey();
                if (StringUtils.isBlank(privateKey)) {
                    continue;
                }
                if (StringUtils.isBlank(applePay.getPublicKeyHash())) {
                    String publicKeyHash = CertificateService.getPublicKeyHash(applePay.getPublicKey());
                    logger.debug("{} does not have publicKeyHash, try to generate and save as: {}", applePay, publicKeyHash);
                    applePay.setPublicKeyHash(publicKeyHash);
                    applePayDao.update(applePay);
                }
                header.setPublicKeyHash(applePay.getPublicKeyHash());
                header.setTransactionId(ApplePayDummyConstant.TRANSACTIONAL_ID);
                applePayPaymentToken.setHeader(header);

                PrivateKey pk = CertificateService.getPrivateKeyFromString(new String(aesCryptUtil.decrypt(Base64.getDecoder().decode(privateKey))), getCertificateType().getAlgorithm());
                String encodedData = encode(pk, applePay, applePayPaymentToken, applePayPaymentData);
                logger.debug("Encoded data: [{}]", encodedData);

                applePayPaymentToken.setData(encodedData);
                applePayPaymentToken.setVersion(getCertificateType().toString());
                //todo: Singature must be generated by our 'privateAppleKey' from the local keyStore
                applePayPaymentToken.setSignature(ApplePayDummyConstant.SIGNATURE);

                return applePayPaymentToken;
            } catch (Exception e) {
                logger.error("Data [{}] wasn't encode with [{}], because: [{}]", applePayPaymentData, applePay, e);
            }
        }
        throw new ApplePayNotFoundException();
    }

    @Override
    public ApplePayCertificateAlgorithm getCertificateType() {
        return null;
    }

    protected boolean isValidate(ApplePay applePay) {
        return true;
    }

    protected abstract String encode(PrivateKey pk, ApplePay applePay, ApplePayPaymentToken applePayPaymentToken, ApplePayPaymentData applePayPaymentData) throws Exception;

    protected String formatPublicKey(String key) {
        key = key.replace("-----BEGIN PUBLIC KEY-----\n", "");
        key = key.replace("-----BEGIN PUBLIC KEY-----", "");
        key = key.replace("-----END PUBLIC KEY-----", "");
        return key;
    }
}
